#!/usr/bin/env ruby
# frozen_string_literal: true

#
# scripts/story-list - List pipeline stories from GitHub Issues
#
# Usage: story-list [--repo OWNER/REPO] [--state open|closed|all]
#
# Output: JSON {"ok": true, "items": [...]}
# Exit code: 0 always
#

require 'json'
require 'optparse'

VALID_STATES = %w[open closed all].freeze

def main
  state = 'open'
  nwo = nil

  OptionParser.new do |opts|
    opts.banner = <<~HELP
      Usage: story-list [--repo OWNER/REPO] [--state open|closed|all]

      List pipeline stories from GitHub Issues.

      Flags:
        --repo OWNER/REPO   GitHub repo (optional)
        --state STATE       Filter by state: open, closed, all (default: open)

      Output:
        JSON {"ok": true, "items": [...]}
        Each item: {number, title, state}

      Examples:
        story-list                                # open stories
        story-list --state all                    # all stories
        story-list --repo mgreenly/ikigai         # stories in specific repo
    HELP

    opts.on('--repo=REPO', 'GitHub repo (OWNER/REPO)') { |r| nwo = r }
    opts.on('--state=STATE', VALID_STATES, 'Filter by state') { |s| state = s }
  end.parse!

  # Query GitHub Issues
  cmd = [
    'gh', 'issue', 'list',
    '--label', 'pipeline,story',
    '--json', 'number,title,state',
    '--limit', '100',
    '--state', state
  ]
  cmd += ['--repo', nwo] if nwo

  stdout = IO.popen(cmd, err: '/dev/null', &:read)

  if $?.exitstatus != 0
    puts JSON.generate(ok: false, items: ['gh issue list failed'])
    exit 0
  end

  issues = JSON.parse(stdout) rescue []

  items = issues.map do |issue|
    {
      number: issue['number'],
      title: issue['title'],
      state: issue['state']
    }
  end

  puts JSON.generate(ok: true, items: items)
  exit 0
end

if __FILE__ == $PROGRAM_NAME
  begin
    main
  rescue Interrupt
    exit 130
  end
end
