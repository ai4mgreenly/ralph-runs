#!/usr/bin/env ruby
# frozen_string_literal: true

#
# scripts/ralph-runs/run - Pipeline orchestrator for concurrent goal execution
#
# Usage: ralph-runs --max N [--model MODEL] [--reasoning LEVEL] [--duration DURATION]
#
# Picks up queued goals, spawns ralphs in isolated clones, collects results,
# creates PRs on success, retries on failure, and notifies on review.
#
# Arguments:
#   --max N            Maximum concurrent ralphs (required)
#   --model MODEL      Model for ralphs: haiku, sonnet, opus (default: sonnet)
#   --reasoning LEVEL  Reasoning level: none, low, med, high (default: med)
#   --duration DUR     Time budget per ralph (e.g., 4h, 200m)
#
# Exit code: 0 on clean shutdown, 130 on interrupt
#

require 'json'
require 'optparse'
require 'fileutils'
require 'set'
require 'open3'
require 'erb'
require 'timeout'

SCRIPT_DIR = File.dirname(File.realpath(__FILE__))
PROJECT_ROOT = File.expand_path('../..', SCRIPT_DIR)
PR_DESCRIPTION_TEMPLATE = File.join(SCRIPT_DIR, 'pr-description.md.erb')
RALPH_DIR = ENV['RALPH_DIR'] || File.join(ENV['HOME'], '.local', 'state', 'ralph')
CLONE_DIR = File.join(RALPH_DIR, 'clones')
LOG_DIR = File.join(RALPH_DIR, 'logs')
LOG_FILE = File.join(LOG_DIR, 'ralph-runs.log')
RALPH_SCRIPT = File.join(SCRIPT_DIR, '..', 'ralph', 'run')
NOTIFY_SCRIPT = File.join(SCRIPT_DIR, '..', 'notify', 'run')
GOAL_LIST_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-list', 'run')
GOAL_GET_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-get', 'run')
GOAL_START_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-start', 'run')
GOAL_DONE_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-done', 'run')
GOAL_STUCK_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-stuck', 'run')
GOAL_COMMENT_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-comment', 'run')
GOAL_COMMENTS_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-comments', 'run')
GOAL_RETRY_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-retry', 'run')
GOAL_SPOT_CHECK_SCRIPT = File.join(SCRIPT_DIR, '..', 'goal-spot-check', 'run')
MAX_RETRIES = 3

def init_log
  FileUtils.mkdir_p(LOG_DIR)
  @log_file = File.open(LOG_FILE, 'w')
end

def log(message)
  timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')
  line = "[#{timestamp}] #{message}"
  puts line
  $stdout.flush
  @log_file.puts(line)
  @log_file.flush
end

def run_script(script, *args)
  cmd = [script] + args
  stdout = IO.popen(cmd, err: '/dev/null', &:read)
  return nil unless $?.exitstatus == 0

  JSON.parse(stdout)
rescue JSON::ParserError
  nil
end

def post_comment(goal_id, body)
  IO.popen([GOAL_COMMENT_SCRIPT, goal_id.to_s], 'r+', err: '/dev/null') do |io|
    io.write(body)
    io.close_write
    io.read
  end
rescue StandardError
  nil
end

def get_goal_comments(goal_id)
  result = run_script(GOAL_COMMENTS_SCRIPT, goal_id.to_s)
  (result && result['ok'] && result['items']) || []
end

def build_retry_context(goal_body, comments)
  parts = [goal_body]

  parts << "\n## Retry Context"
  parts << "\nThis is a retry of a failed attempt."

  unless comments.empty?
    parts << "\n### Comments"
    comments.each do |comment|
      created = comment['created_at'] || ''
      parts << "\n*#{created}:*"
      parts << comment['body']
      parts << ""
    end
  end

  parts.join("\n")
end

def ensure_pipeline_cache(dest)
  cache_dir = File.join(dest, '.pipeline', 'cache')
  gitkeep = File.join(cache_dir, '.gitkeep')
  return if File.exist?(gitkeep)

  FileUtils.mkdir_p(cache_dir)
  FileUtils.touch(gitkeep)
  system('jj', 'commit', '-m', 'Add .pipeline/cache directory',
         chdir: dest, out: '/dev/null', err: '/dev/null')
end

def add_pr_label(pr_number, label, nwo)
  system('gh', 'pr', 'edit', pr_number.to_s,
         '--repo', nwo,
         '--add-label', label,
         out: '/dev/null', err: '/dev/null')
end

def clone_repo(remote_url, org, repo, goal_id)
  dest = File.join(CLONE_DIR, org, repo, goal_id.to_s)
  FileUtils.mkdir_p(File.dirname(dest))
  system('git', 'clone', '--quiet', remote_url, dest, out: '/dev/null', err: '/dev/null')
  return nil unless $?.exitstatus == 0

  # Initialize jj so ralph's commits work inside the clone
  system('jj', 'git', 'init', chdir: dest, out: '/dev/null', err: '/dev/null')

  # Ensure .pipeline/cache/ is tracked so it survives jj commits
  ensure_pipeline_cache(dest)
  dest
end

def delete_clone(org, repo, goal_id)
  dest = File.join(CLONE_DIR, org, repo, goal_id.to_s)
  FileUtils.rm_rf(dest) if Dir.exist?(dest)
end

def generate_pr_description(clone_dir)
  goal_file = File.join(clone_dir, '.pipeline', 'cache', 'goal.md')
  progress_file = File.join(clone_dir, '.pipeline', 'cache', 'goal-progress.jsonl')

  # Read goal body
  return nil unless File.exist?(goal_file)
  goal = File.read(goal_file)

  # Read progress entries
  progress_entries = []
  if File.exist?(progress_file)
    File.readlines(progress_file).each do |line|
      entry = JSON.parse(line.strip)
      progress_entries << entry['progress'] if entry['progress']
    end
  end

  # Render ERB template
  template = ERB.new(File.read(PR_DESCRIPTION_TEMPLATE))
  prompt = template.result(binding)

  # Invoke Claude with Haiku model
  schema = JSON.generate({
    type: 'object',
    properties: {
      description: { type: 'string' }
    },
    required: ['description']
  })
  cmd = ['claude', '-p', '--model', 'haiku', '--json-schema', schema]

  stdout, stderr, status = Timeout.timeout(60) do
    Open3.capture3({'ANTHROPIC_API_KEY' => ''}, *cmd, stdin_data: prompt)
  end
  return nil unless status.exitstatus == 0

  result = JSON.parse(stdout)
  result['description']
rescue StandardError => e
  log "PR description generation failed: #{e.class}: #{e.message}"
  nil
end

def create_pr_from_clone(goal_id, title, clone_dir, nwo)
  branch = "goal-#{goal_id}-#{Time.now.to_i.to_s(36)}"

  # Commit any uncommitted working copy changes
  system('jj', 'commit', '-m', "Goal ##{goal_id}: #{title}",
         chdir: clone_dir, out: '/dev/null', err: '/dev/null')

  # Check if there are commits beyond main
  jj_log = IO.popen(['jj', 'log', '-r', 'main@origin..@-', '--no-graph', '-T', 'change_id.short()'],
                     chdir: clone_dir, err: '/dev/null', &:read)
  if jj_log.strip.empty?
    log "Goal ##{goal_id} no changes to push, skipping PR"
    return nil
  end

  # Create bookmark on last commit, track, and push
  system('jj', 'bookmark', 'create', branch, '-r', '@-',
         chdir: clone_dir, out: '/dev/null', err: '/dev/null')
  system('jj', 'bookmark', 'track', "#{branch}@origin",
         chdir: clone_dir, out: '/dev/null', err: '/dev/null')
  system('jj', 'git', 'push', '--bookmark', branch,
         chdir: clone_dir, out: '/dev/null', err: '/dev/null')

  unless $?.exitstatus == 0
    log "Goal ##{goal_id} failed to push"
    return nil
  end

  # Create PR
  generated_desc = generate_pr_description(clone_dir)
  if generated_desc && !generated_desc.empty?
    body = "#{generated_desc}\n\nGoal ##{goal_id}"
  else
    body = "Goal ##{goal_id}"
  end

  pr_output = IO.popen(
    ['gh', 'pr', 'create', '--repo', nwo, '--title', title, '--body', body, '--head', branch],
    chdir: clone_dir, err: '/dev/null', &:read
  )

  if $?.exitstatus == 0
    pr_num = pr_output.strip.split('/').last
    pr_num
  else
    log "Goal ##{goal_id} failed to create PR"
    nil
  end
end

def notify(title, message)
  payload = JSON.generate(title: title, message: message)
  IO.popen(NOTIFY_SCRIPT, 'r+') do |io|
    io.write(payload)
    io.close_write
    io.read
  end
rescue StandardError
  # Notification failure is non-fatal
end

def format_elapsed(seconds)
  hours, remainder = seconds.divmod(3600)
  mins, secs = remainder.divmod(60)
  if hours > 0
    "#{hours}h#{mins}m#{secs}s"
  elsif mins > 0
    "#{mins}m#{secs}s"
  else
    "#{secs}s"
  end
end

def goal_label(goal_id, repo_info)
  "Goal ##{goal_id} (#{repo_info[:nwo]})"
end

def main(options)
  init_log

  max_slots = options[:max]
  model = options[:model]
  reasoning = options[:reasoning]
  duration = options[:duration]

  log "Starting orchestrator (max #{max_slots} ralphs)"
  log "Model: #{model} | Reasoning: #{reasoning} | Duration: #{duration || 'unlimited'}"

  # State tracking
  running = {}                # pid => {goal_id:, title:, review:, dir:, started_at:, stream_thread:, wait_thread:, repo:}
  retries = Hash.new(0)       # goal_id => retry count
  attempted = Set.new         # goal_id
  completed_count = 0
  last_queued_count = nil
  last_running_count = nil
  last_completed_count = nil
  @shutting_down = false

  # Ctrl+C handler
  trap('INT') do
    @shutting_down = true
  end

  loop do
    # ── Shutdown ──
    if @shutting_down
      log 'Shutting down...'
      running.each do |pid, info|
        Process.kill('INT', pid) rescue nil
        Process.wait(pid) rescue nil
        info[:stream_thread]&.join rescue nil

        ri = info[:repo]
        goal_id = info[:goal_id]

        # Mark stuck, then requeue
        run_script(GOAL_STUCK_SCRIPT, goal_id.to_s)
        run_script(GOAL_RETRY_SCRIPT, goal_id.to_s)
        log "#{goal_label(goal_id, ri)} → re-queued (was running)"

        delete_clone(ri[:org], ri[:repo], goal_id)
        log "Cleaned up clones/#{ri[:org]}/#{ri[:repo]}/#{goal_id}/"
      end
      log 'Done'
      break
    end

    # ── Collect finished ralphs ──
    finished = []
    running.each do |pid, info|
      unless info[:wait_thread].alive?
        status = info[:wait_thread].value
        finished << [pid, status]
      end
    end

    finished.each do |pid, status|
      info = running.delete(pid)
      goal_id = info[:goal_id]
      ri = info[:repo]
      nwo = ri[:nwo]
      org = ri[:org]
      repo_name = ri[:repo]
      elapsed = format_elapsed((Time.now - info[:started_at]).to_i)
      gl = goal_label(goal_id, ri)

      # Wait for stream thread to finish writing all output
      info[:stream_thread]&.join

      if status.exitstatus == 0
        log "#{gl} ralph finished (exit 0, #{elapsed})"

        # Create PR
        pr_num = create_pr_from_clone(goal_id, info[:title], info[:dir], nwo)
        if pr_num
          log "#{gl} PR created → ##{pr_num}"
        end

        if info[:review]
          # Review goal — transition to reviewing, label PR, keep clone
          run_script(GOAL_SPOT_CHECK_SCRIPT, goal_id.to_s, 'set')
          if pr_num
            add_pr_label(pr_num, 'goal:review', nwo)
            log "#{gl} PR ##{pr_num} labeled goal:review"
          end
          log "#{gl} → reviewing"
        else
          # Non-review goal — mark done, auto-merge, delete clone
          run_script(GOAL_DONE_SCRIPT, goal_id.to_s)
          if pr_num
            merge_cmd = ['gh', 'pr', 'merge', '--repo', nwo, '--auto', '--squash', pr_num.to_s]
            if system(*merge_cmd, out: '/dev/null', err: '/dev/null')
              log "#{gl} auto-merge enabled on PR ##{pr_num}"
            else
              log "#{gl} auto-merge failed on PR ##{pr_num} (non-fatal)"
            end
          end
          completed_count += 1
          log "#{gl} → done"
          delete_clone(org, repo_name, goal_id)
        end
      else
        log "#{gl} ralph finished (exit #{status.exitstatus}, #{elapsed})"
        retries[goal_id] += 1

        if retries[goal_id] > MAX_RETRIES
          run_script(GOAL_STUCK_SCRIPT, goal_id.to_s)
          log "#{gl} → stuck (#{retries[goal_id]} retries exhausted)"
          notify("#{gl} stuck", "\"#{info[:title]}\" failed #{retries[goal_id]} times")
          delete_clone(org, repo_name, goal_id)
        else
          # Post failure context, mark stuck, requeue
          post_comment(goal_id, "Ralph failed (exit #{status.exitstatus}, attempt #{retries[goal_id]}/#{MAX_RETRIES})")
          run_script(GOAL_STUCK_SCRIPT, goal_id.to_s)
          run_script(GOAL_RETRY_SCRIPT, goal_id.to_s)
          log "#{gl} failed → re-queued (retry #{retries[goal_id]}/#{MAX_RETRIES})"
          delete_clone(org, repo_name, goal_id)
        end
      end
    end

    # ── Clean up review clones ──
    # Traverse clones/<org>/<repo>/<goal_id>/ structure
    Dir.glob(File.join(CLONE_DIR, '*', '*', '*')).each do |clone_path|
      next unless File.directory?(clone_path)

      goal_id = File.basename(clone_path).to_i
      next if goal_id == 0  # Skip non-numeric directories

      # Don't delete clones for currently running goals
      next if running.values.any? { |info| info[:goal_id] == goal_id }

      # Check if goal is no longer in reviewing state
      goal_data = run_script(GOAL_GET_SCRIPT, goal_id.to_s)
      next unless goal_data && goal_data['ok']

      unless goal_data['status'] == 'reviewing'
        parts = clone_path.sub("#{CLONE_DIR}/", '').split('/')
        clone_org = parts[0]
        clone_repo = parts[1]
        delete_clone(clone_org, clone_repo, goal_id)
        log "Cleaned up clones/#{clone_org}/#{clone_repo}/#{goal_id}/ (goal no longer in reviewing)"
      end
    end

    # ── Fill open slots ──
    result = run_script(GOAL_LIST_SCRIPT, '--status', 'queued')
    all_queued = (result && result['ok'] && result['items']) || []
    all_queued.each do |g|
      g['_repo'] = { org: g['org'], repo: g['repo'], nwo: "#{g['org']}/#{g['repo']}" }
    end

    queued_count = all_queued.size
    running_count = running.size

    if queued_count != last_queued_count || running_count != last_running_count || completed_count != last_completed_count
      status_parts = []
      status_parts << "#{queued_count} queued"
      status_parts << "#{running_count} running"
      status_parts << "#{completed_count} completed"
      log status_parts.join(', ')
      last_queued_count = queued_count
      last_running_count = running_count
      last_completed_count = completed_count
    end

    available_slots = max_slots - running.size

    if available_slots > 0
      # Sort by goal id ascending (FIFO)
      all_queued.sort_by! { |g| g['id'] }

      # Partition into untried and retried goals for fairness
      untried = all_queued.reject { |g| attempted.include?(g['id']) }
      retried = all_queued.select { |g| attempted.include?(g['id']) }

      # Dispatch untried goals first, then retried
      candidates = (untried + retried).first(available_slots)

      candidates.each do |goal|
        ri = goal['_repo']
        nwo = ri[:nwo]
        org = ri[:org]
        remote_url = "git@github.com:#{org}/#{ri[:repo]}.git"
        repo_name = ri[:repo]
        goal_id = goal['id']
        title = goal['title']
        review = goal['review']
        gl = goal_label(goal_id, ri)

        # Transition to running (race-safe: skip on failure)
        start_result = run_script(GOAL_START_SCRIPT, goal_id.to_s)
        unless start_result && start_result['ok']
          log "#{gl} failed to start (already claimed?), skipping"
          next
        end
        log "#{gl} \"#{title}\" → running (slot #{running.size + 1}/#{max_slots})"

        # Clone
        clone_dir = clone_repo(remote_url, org, repo_name, goal_id)
        unless clone_dir
          log "#{gl} clone failed, marking stuck and requeuing"
          run_script(GOAL_STUCK_SCRIPT, goal_id.to_s)
          run_script(GOAL_RETRY_SCRIPT, goal_id.to_s)
          next
        end
        log "#{gl} cloned to clones/#{org}/#{repo_name}/#{goal_id}/"

        # Fetch goal body
        goal_data = run_script(GOAL_GET_SCRIPT, goal_id.to_s)
        unless goal_data && goal_data['ok']
          log "#{gl} failed to fetch goal body, marking stuck and requeuing"
          run_script(GOAL_STUCK_SCRIPT, goal_id.to_s)
          run_script(GOAL_RETRY_SCRIPT, goal_id.to_s)
          delete_clone(org, repo_name, goal_id)
          next
        end

        # Build goal file — augment with retry context if comments exist
        goal_body = goal_data['body']
        if retries[goal_id] > 0
          comments = get_goal_comments(goal_id)
          goal_body = build_retry_context(goal_body, comments) unless comments.empty?
        end

        # Write goal body into .pipeline/cache/
        cache_dir = File.join(clone_dir, '.pipeline', 'cache')
        FileUtils.mkdir_p(cache_dir)
        goal_file = File.join(cache_dir, 'goal.md')
        File.write(goal_file, goal_body)

        # Spawn ralph with real-time log streaming
        ralph_log = File.join(cache_dir, 'ralph.log')
        ralph_args = [
          RALPH_SCRIPT,
          "--goal=.pipeline/cache/goal.md",
          '--log-mode',
          '--no-pull-request',
          "--model=#{model}",
          "--reasoning=#{reasoning}",
          "--name=#{title}"
        ]
        ralph_args << "--duration=#{duration}" if duration

        # Use Open3.popen2e to stream output with proper wait_thread handling
        log_file = File.open(ralph_log, 'w')
        stdin, stdout_and_stderr, wait_thread = Open3.popen2e(*ralph_args, chdir: clone_dir)
        stdin.close  # We don't need stdin
        pid = wait_thread.pid

        # Stream output in a background thread
        stream_thread = Thread.new do
          begin
            stdout_and_stderr.each_line do |line|
              log_file.puts(line)
              log_file.flush
            end
          ensure
            stdout_and_stderr.close
            log_file.close
          end
        end

        log "#{gl} ralph started (pid #{pid}, log: clones/#{org}/#{repo_name}/#{goal_id}/.pipeline/cache/ralph.log)"

        # Mark this goal as attempted for fairness tracking
        attempted.add(goal_id)

        running[pid] = {
          goal_id: goal_id,
          title: title,
          review: review,
          dir: clone_dir,
          started_at: Time.now,
          stream_thread: stream_thread,
          wait_thread: wait_thread,
          repo: ri
        }
      end
    end

    # ── Sleep ──
    sleep 5
  end
end

# ─────────────────────────────────────────────────────────────
# CLI
# ─────────────────────────────────────────────────────────────

options = {
  model: 'sonnet',
  reasoning: 'med'
}

OptionParser.new do |opts|
  opts.banner = <<~BANNER
    ralph-runs - Pipeline coordinator for concurrent goal execution

    Usage: ralph-runs --max N [options]
  BANNER

  opts.on('--max=N', Integer, 'Maximum concurrent ralphs (required)') do |n|
    options[:max] = n
  end

  opts.on('--model=MODEL', %w[haiku sonnet opus], 'Model: haiku, sonnet, opus (default: sonnet)') do |m|
    options[:model] = m
  end

  opts.on('--reasoning=LEVEL', %w[none low med high], 'Reasoning: none, low, med, high (default: med)') do |r|
    options[:reasoning] = r
  end

  opts.on('--duration=DURATION', 'Time budget per ralph (e.g., 4h, 200m)') do |d|
    options[:duration] = d
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

if options[:max].nil? || options[:max] < 1
  $stderr.puts 'Error: --max=N is required (must be >= 1)'
  $stderr.puts 'Usage: ralph-runs --max N [options]'
  exit 1
end

if __FILE__ == $PROGRAM_NAME
  begin
    main(options)
  rescue Interrupt
    exit 130
  end
end
